###### [返回主页](../README.md)

------

# 计算机组成原理

## 第1章 计算机系统概论

### 1.1 计算机系统简介

#### 计算机系统由硬件和软件两大部分组成

- 硬件：计算机实体部分
- 软件：
  - 系统软件：管理整个计算机系统（标准程序库、语言处理程序、操作系统、DBMS）
  - 应用软件：用户根据任务需要所编制的各种程序

#### 计算机系统层次  

- 虚拟机器M4：高级语言机器（用 **编译程序** 翻译成 **汇编语言** 程序）  
- 虚拟机器M3：汇编语言机器（用 **汇编程序** 翻译成 **机器语言** 程序）  
- 虚拟机器M2：操作系统机器（用 **机器语言** 解释 **操作系统**）  
- 传统机器M1：机器语言机器（用 **微程序** 解释 **机器指令**）  
- 微程序机器M0：微指令系统（由硬件直接执行 **微指令**）

#### 计算机组成和计算机体系结构  

- 计算机体系结构：能被程序员看到的计算机系统的属性（*指令集、数据类型、存制技术、IO机理等*）
- 计算机组成：实现体系结构所体现的属性，包含了许多对程序员透明的硬件细节

### 1.2 计算机的基本组成

#### 冯诺依曼计算机的特点  

1. 计算机由 **运算器 存储器 控制器 输入设备 输出设备** 五大部件组成  
2. 指令和数据以**同等**地位存放于存储器内**按地址访问**  
3. 指令和数据用二进制表示  
4. 指令由操作码和地址码组成  
5. 指令在存储器内部按**顺序**存放  
6. 机器以**运算器**为中心  

#### 计算机的工作步骤

- 上机前的准备：  
  建立数学模型->确定计算方法->编制解题程序  
  
- 计算机的工作过程  
  - **存储器**  
    存储体-存储单元-存储元件（0/1）  
    大楼-房间-床位（无人/有人）  
    *MAR*存储器地址寄存器（反应存储单元的格式）  
    *MDR*存储器数据寄存器（反应存储字长）
  - **运算器**
    *ALU*算术逻辑单元  
    *ACC*累加器  
    *MQ*乘商寄存器  
    *X*操作数寄存器  
    ![JxlFEQ.png](https://s1.ax1x.com/2020/05/02/JxlFEQ.png)
    - 加法操作过程  
      ![JxlTGn.png](https://s1.ax1x.com/2020/05/02/JxlTGn.png)  
    - 减法操作过程  
      ![Jx1HFH.png](https://s1.ax1x.com/2020/05/02/Jx1HFH.png)
    - 乘法操作过程  
      ![Jx1owD.png](https://s1.ax1x.com/2020/05/02/Jx1owD.png)
    - 除法操作过程  
      ![Jx1TTe.png](https://s1.ax1x.com/2020/05/02/Jx1TTe.png)
  - **控制器**
    - 取指令(程序计数器PC)
    - 分析指令(指令寄存器IR)
    - 执行指令(控制单元CU)
  - **IO**

### 1.3 计算机硬件的主要指标

- 机器字长：CPU一次能处理的数据位数，与CPU中的*寄存器位数*有关
- 运算速度
  - 主频
  - 核数
  - CPI:执行一条指令所需时钟周期
  - MIPS:每秒执行百万条指令
  - FLOPS:每秒浮点运算次数
- 存储容量：
  - 主存容量
    - 存储单元格式\*存储字长(1K\*8位)
    - 字节数(1 KB)
  - 辅存容量

---

## 第2章 计算机的发展及应用  

### 2.1 计算机的发展

1. 第一代计算机  
   采用电子管作为运算和逻辑单元，用机器语言和汇编语言编程，主要用于科学计算和工程设计。
2. 第二代计算机  
   采用晶体管代替电子管，开始使用高级语言。
3. 第三代计算机  
   采用中小规模集成电路。
4. 第四代计算机  
   采用大规模集成电路和超大规模集成短路，软件方面发展了DBMS以及网络软件等。

### 2.2 Moore定律

微芯片上集成的晶体管数目每三年翻两番

### 2.3 软件技术的发展

1. 各种语言  
   机器语言 面向机器  
   汇编语言 面向机器  
   高级语言 面向问题  
2. 系统软件  
   语言处理程序（汇编程序、编译程序、解释程序）  
   操作系统  
   服务性程序（装配、调试、诊断、排错）  
   数据库管理系统  
   网络软件  
3. 软件发展特点  
   开发周期长  
   制作成本昂贵  
   检测软件产品质量的特殊性  

---

## 第3章 系统总线

### 3.1 总线的基本概念

- 总线是连接各个部件的信息传输线，是各个部件*共享*的传输介质
- 总线上信息的传送
  - 串行
  - 并行
- 总线结构举例
  - 单总线结构  
    ![JzRPFe.png](https://s1.ax1x.com/2020/05/03/JzRPFe.png)
  - 面向CPU的双总线结构  
    ![JzRb0f.png](https://s1.ax1x.com/2020/05/03/JzRb0f.png)
  - 以存储器为中心的双总线结构  
    ![JzR9oD.png](https://s1.ax1x.com/2020/05/03/JzR9oD.png)

### 3.2 总线的分类

1. 片内总线 芯片内部的总线
2. 系统总线 计算机各部件之间的信息传输线
   - 数据总线 **双向** 与机器字长和存储字长有关
   - 地址总线 **单向** 与存储地址、IO地址有关
   - 控制总线 **有出 有入**
3. 通信总线 用于计算机系统之间或计算机系统与其他系统之间的通信
   - 串行总线
   - 并行总线

### 3.3 总线的特征及性能指标

#### 总线的特征

- 机械特性 尺寸、形状、管脚数
- 电气特性 传输方向、有效电平范围
- 功能特性 每根传输线的功能
- 时间特性 时序关系

#### 总线的性能指标

- 总线的宽度 *数据线的根数*
- 标准传输率 *每秒传输的最大字节数（MBps）*
- 时钟同步/异步 *同步、不同步*
- 总线复用 *地址线与数据线复用*
- 信号线数 *地址线、数据线、控制线总和*
- 总线控制方式 *突发、自动、仲裁、逻辑、计数*
- 其他指标 *负载能力*

### 3.4 总线结构

- 单总线结构
- 多总线结构
  - 双总线结构  
    ![YpP4fS.png](https://s1.ax1x.com/2020/05/03/YpP4fS.png)
  - 三总线结构  
    ![YpPhY8.png](https://s1.ax1x.com/2020/05/03/YpPhY8.png)  
    ![YpPRTP.png](https://s1.ax1x.com/2020/05/03/YpPRTP.png)
  - 四总线结构  
    ![YpPfFf.png](https://s1.ax1x.com/2020/05/03/YpPfFf.png)

### 3.5 总线控制

#### 总线判优控制

- 基本概念
  - 主设备（模块） 对总线有**控制权**
  - 从设备（模块） **响应**从主设备发来的总线命令
- 总线判优控制
  - 集中式
    - 链式查询  
      只用很少的几根线就能按照一定优先次序实现总线控制，并且很容易扩充设备  
      但是对电路故障敏感，优先级低的设备很难获得请求  
      ![YpFxsJ.png](https://s1.ax1x.com/2020/05/03/YpFxsJ.png)
    - 计数器定时查询  
      计数可以从0开始，也可以从上一次计数的终点开始  
      对电路故障不如链式查询敏感，但增加了设备地址线，控制比较复杂  
      ![YpFXzF.png](https://s1.ax1x.com/2020/05/03/YpFXzF.png)
    - 独立请求方式  
      总线控制部件中有一排队电路，可根据优先次序确定响应哪一台设备的请求  
      响应速度更快，优先次序控灵活，但是空实现数量太多，总线控制更复杂  
      ![YpFvM4.png](https://s1.ax1x.com/2020/05/03/YpFvM4.png)
  - 分布式

#### 总线通信控制

- 目的：解决通信双方协调配合问题
- 总线传输周期
  - 申请分配阶段 主模块**申请**，总线仲裁决定
  - 寻址阶段 主模块向从模块给出**地址和命令**
  - 传数阶段 主模块和从模块**交换数据**
  - 结束阶段 主模块撤销有关信息
- 总线的通信方式
  - 同步通信 统一时标
  - 异步通信 应答方式
    - 不互锁
    - 半互锁
    - 全互锁
  - 半同步通讯 同步、异步相结合
  - 分离式通讯 充分挖掘系统总线每个瞬间的潜力
    - 各模块有权申请占用总线
    - 采用同步方式通信，不等对方回答
    - 各模块准备数据时，不占用总线
    - 总线被占用时，无空闲

---

## 第4章 存储器

### 4.1 存储器概述

#### 存储器分类

- 按存储介质分类
  - 半导体存储器（*易失*） TTL、MOS  
  - 磁表面存储器（*非易失*） 磁头、载磁体
  - 磁芯存储器（*非易失*） 硬磁材料、环状元件
  - 光盘存储器（*非易失*） 激光、磁光材料
- 按存取方式分类
  - 随机存储器（*随机访问*） 可读可写
  - 只读存储器（*随机访问*） 只读
  - 顺序存取存储器（*串行访问*） 磁带
  - 直接存取存储器（*串行访问*） 磁盘
- 按在计算机中的作用分类
  - 主存储器
    - RAM
      - 静态RAM
      - 动态RAM
    - ROM
      - MROM
      - PROM
      - EPROM
      - EEPROM
  - Flash Memory
  - Cache
  - 辅助存储器

#### 存储器的层次结构

- 缓存-主存层次  
  解决CPU和主存速度不匹配的问题
- 主存-辅存层次  
  解决存储系统容量问题

### 4.2 主存储器

#### 概述

- 主存的基本组成  
  ![YPSsk6.png](https://s1.ax1x.com/2020/05/04/YPSsk6.png)
- 存储器中存储单元的地址分配  
  ![YPCB0s.png](https://s1.ax1x.com/2020/05/04/YPCB0s.png)
- 主存的技术指标
  - 存储容量 主存存放二进制代码的总位数
  - 存储速度
    - 存取时间
      - 读出时间 *从存储器接收到有效地址开始，到产生有效输出的时间*
      - 写入时间 *从存储器接收到有效地址开始，到数据写入指定单元为止的时间*
    - 存取周期 **连续两次**独立的存储器操作所需要的最小间隔（一般比存取时间长，因为通常加入了刷新时间）

#### 半导体存储芯片简介

- 半导体存储芯片的基本结构  
  ![YPkrKU.png](https://s1.ax1x.com/2020/05/04/YPkrKU.png)
- 半导体存储芯片的译码驱动方式
  - 线选法  
    ![YPudj1.png](https://s1.ax1x.com/2020/05/04/YPudj1.png)
  - 重合法  
    ![YPKrMn.png](https://s1.ax1x.com/2020/05/04/YPKrMn.png)

#### 随机存取存储器

- 静态RAM（SRAM）  
  使用双稳态触发器保存数据
- 动态RAM（DRAM）  
  使用电容保存数据  
  **动态RAM的刷新**：***刷新只与行地址有关***
  - 集中刷新  
    刷新周期内的一段时间连续刷新所有存储单元（存在死区）
  - 分散刷新  
    加长存取周期，没有死区但是存在过度刷新。
  - 异步刷新  
    刷新周期内刷新完所有行即可，将刷新周期平均分成若干时间间隔，对于每个间隔内相当于集中刷新，对于整个刷新周期相当于分散刷新。存在死区但影响小。  
- 动态RAM和静态RAM比较  
  ||DRAM|SRAM|
  |:-:|:-:|:-:|
  |存储原理|电容|触发器|
  |集成度|高|低|
  |芯片引脚|少|多|
  |功耗|小|大|
  |价格|低|高|
  |速度|慢|快|
  |刷新|有|无|

#### 只读存储器

- 掩模ROM（MROM）  
  行列选择线交叉处无MOS管 0  
  行列选择线交叉处有MOS管 1
- PROM（一次性编程）  
  熔丝断 0  
  熔丝未断 1
- EPROM（多次编程）  
  N型沟道浮动MOS电路  
- EEPROM（多次编程）  
  电可擦写  
  局部擦写  
  全部擦写
- Flash Memory（闪存型存储器）  
  已经具备RAM的功能

#### 存储器与CPU的连接

- 存储器的容量扩展
  - 位扩展 增加存储字长  
    ![YZgwrT.png](https://s1.ax1x.com/2020/05/07/YZgwrT.png)
  - 字扩展 增加存储字的数量  
    ![YV8pxx.png](https://s1.ax1x.com/2020/05/06/YV8pxx.png)
  - 字、位扩展  
    ![YV8O6P.png](https://s1.ax1x.com/2020/05/06/YV8O6P.png)

- 存储器与CPU的连接
  - 地址线的连接
  - 数据线的连接
  - 读写命令线的连接
  - 片选线的连接
  - 合理选择存储芯片
  - 其他 时序、负载

#### 存储器的校验

- 编码的最小距离  
  任意两组合法代码之间**二进制位数**的**最小差异**  
  **编码的纠错、检错能力与编码的最小距离有关**  

##### 汉明码

- 汉明码的组成
  - 汉明码采用奇偶校验
  - 汉明码采用分组校验
  - 汉明码的分组是一种非划分方式  
    ![YeFLUf.png](https://s1.ax1x.com/2020/05/07/YeFLUf.png)
  - 汉明码的三要素
    - 增加K位检测位  
      $2^k \ge n+k+1$
    - 检测位的位置  
      $2^i(i=0,1,2,3,...)$
    - 检测位的取值  
      奇校验或偶校验（默认偶校验）
- 汉明码的纠错过程
  - 奇配置纠错时用同或
  - 偶配置纠错时用异或  
    ![Yee13T.png](https://s1.ax1x.com/2020/05/07/Yee13T.png)

##### 循环冗余校验码（CRC码）

![YMVPhR.png](https://s1.ax1x.com/2020/05/09/YMVPhR.png)

#### 提高访存速度的措施

- 采用高速器件
- 采用层次结构Cache-主存
- 调整主存结构

1. 单体多字系统（增加存储器带宽）  
   ![Ye1sHS.png](https://s1.ax1x.com/2020/05/07/Ye1sHS.png)

2. 多体并行系统
   1. 高位交叉编址 顺序编址
      使不同的请求源同时访问不同的体，便可实现并行工作；但指令往往顺序存储，容易出现只在一个体中取指令其他体空闲的情况。  
      ***主要应用于存储器容量扩展***  
      ![Ye8pMq.png](https://s1.ax1x.com/2020/05/07/Ye8pMq.png)
   2. 低位交叉编址 各个体轮流编址  
      CPU在同一个主存周期可以访问多个体，在体将数据准备好后可以向CPU传输。总线使用分离式通信。  
      低位交叉编址可以在不改变存取周期的前提下，增加存储器带宽。  
      ***主要用于存储器带宽和访问速度的提高***  
      ![Ye88Fe.png](https://s1.ax1x.com/2020/05/07/Ye88Fe.png)
3. 高性能存储芯片
   1. SDRAM（同步DRAM）  
      在系统时钟的控制下进行读出和写入  
      **CPU无需等待**
   2. RDRAM  
      主要解决带宽问题  
   3. 带Cache的DRAM  
      内部集成了SRAM组成的Cache，有利于猝发式读取

### 4.3 高速缓冲存储器

#### Cache概述

- **程序的局部性原理**
  - 时间的局部性  
    当前正在使用的指令和数据在不久的将来还会使用到
  - 空间的局部性  
    当前正在使用的一个指令或者数据，在不久的将来相邻的指令或者数据会被使用到
- Cache是为解决CPU与主存速度不匹配
- Cache的读操作  
  CPU发出访问地址后先判断是否在Cache中  
  若不在，则在主存中寻找，并将新的内存块调入Cache中  
  若Cache已满，则执行替换算法腾出空位
- Cache的写操作  
  - 写直达  
    写操作数时既写入Cache又写入主存  
    写操作时间就是访问主存的事件，Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现
  - 写回法  
    写操作时只把数据写入Cache而不写入主存，当Cache数据被替换出去时才写回主存
- Cache的改进
  - 增加Cache的级数  
    片载Cache  
    片外Cache  
  - 统一缓存和分立缓存  
    指令Cache  
    数据Cache  
    与指令执行的控制方式有关

#### Cache-主存的地址映射

1. 直接映射  
   **每个缓存块i**可以和**若干个主存**块对应  
   **每个主存块j**只能和**一个缓存块**对应  
   缺点是不够灵活，使缓存空间得不到充分利用
   [![YmnJIA.png](https://s1.ax1x.com/2020/05/07/YmnJIA.png)](https://imgchr.com/i/YmnJIA)
2. 全相联映射  
   **任何块**可以放在**任何位置**  
   缺点是逻辑电路复杂  
   ![Ym1pG9.png](https://s1.ax1x.com/2020/05/07/Ym1pG9.png)
3. 组相联映射  
   将Cache分成Q组，将主存分区每个区Q块  
   映射的时候**主存每个区的i块**可以放在**Cache第i组的任何位置**  
   ![Ym3Sw8.png](https://s1.ax1x.com/2020/05/07/Ym3Sw8.png)

#### 替换算法

1. 先进先出算法FIFO
2. 近期最少使用算法LRU
3. 随机法

---

## 第5章 输入输出系统

### 5.1 IO概述

#### IO系统的发展概述

- 早期
  - 分散连接
  - CPU和IO设备 **串行**工作 程序查询方式
- 接口模块和DMA阶段
  - 总线连接
  - CPU和IO设备 **并行**工作 中断方式、DMA方式
  - 具有通道结构的阶段

#### IO系统的组成

- IO软件
  - IO指令  
    *CPU指令的一部分*  
    操作码+命令码+设备码
  - 通道指令  
    *通道自身的指令*  
    指出数据的首地址、传送字数、操作命令
- IO硬件
  - 设备-IO接口
  - 设备-设备控制器-通道

#### IO设备与主机的联系方式

- IO设备编址方式
  - 统一编址 用取数、存数指令
  - 不统一编址（单独编址） 有专门的IO指令
- 设备选址
  用设备选择电路识别是否被选中
- 传送方式
  - 串行
  - 并行
- 联络方式
  - 立即响应
  - 异步工作采用应答信号
  - 同步工作采用同步时标
- IO设备与主机的连接方式
  - 辐射式连接
  - 总线连接
    便于增删设备

#### IO设备与主机信息传送的控制方式

- 程序查询方式  
  CPU读IO状态，循环检查设备是否就绪（CPU踏步等待）  
  **CPU和IO串行工作**
- 程序中断方式  
  IO工作分为两个阶段：  
  自身准备阶段 CPU不查询  
  与主机交换信息 CPU暂停现行程序  
  **CPU和IO部分的并行工作**
- DMA方式  
  主存和IO之间有一条直接的数据通道  
  不中断现行程序  
  周期挪用
- 三种方式的比较  
  ![YmoAI0.png](https://s1.ax1x.com/2020/05/07/YmoAI0.png)

### 5.2 IO设备

- 人机交互设备 *鼠标、键盘、打印机、显示器*
- 计算机信息存储设备 *磁盘、光盘、磁带*
- 机-机通信设备 *调制解调器*

### 5.3 IO接口

- 为什么需要设置接口？  
  实现设备的选择  
  实现数据缓冲达到速度匹配  
  实现数据串-并格式转换  
  实现电平转换  
  传送控制命令  
  反应设备的状态（忙、就绪、中断请求

#### 接口的功能和组成

|功能|组成|
|:-:|:-:|
|选址功能|设备选择电路|
|传送命令的功能|命令寄存器、命令译码器|
|传送数据的功能|数据缓冲寄存器|
|反映设备状态的功能|设备状态标记|

#### 接口的类型

- 按数据传送方式分类
  - 并行接口
  - 串行接口
- 按功能选择的灵活性分类
  - 可编程接口
  - 不可编程接口
- 按照通用性分类
  - 通用接口
  - 专用接口
- 按照数据传送的控制方式分类
  - 中断接口
  - DMA接口

### 5.4 程序查询方式

#### 程序查询流程

- 查询流程  
  检查状态标记->循环判断是否准备就绪->交换数据  
  多个设备时按照优先级检查状态标记  
- 程序流程  
  ![YnToZj.png](https://s1.ax1x.com/2020/05/08/YnToZj.png)

### 5.5 程序中断方式

#### 中断的概念

计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向这些异常情况或特殊请求的处理，处理结束再返回现行程序的间断处继续执行原程序

#### CPU响应中断的条件

- 有中断请求
- 开中断
- 一条指令执行完毕

#### 中断隐指令

中断隐指令并不是一条真正的指令，是进入中断服务程序前由**硬件**执行的一系列操作。其所完成的操作有：

- 保存断点
- 关中断
- 引出中断服务程序
  将中断服务程序入口地址送入PC

#### 中断服务程序的流程

- 中断服务程序的流程
  - 保护现场  
    程序断点的保护 中断隐指令完成  
    寄存器内容的保护 进栈指令
  - 中断服务  
    对不同的IO设备具有不同内容的设备服务
  - 恢复现场  
    使用出栈指令
  - 中断返回  
    使用中断返回指令
- 单重中断和多重中断
  - 单重中断  
    不允许中断现行的中断服务程序
  - 多重中断  
    允许更高级别的中断源中断现行的中断服务程序
- 单重中断和多重中断的服务程序流程  
 ![Ynxscn.png](https://s1.ax1x.com/2020/05/08/Ynxscn.png)

### 5.6 DMA方式的特点

#### DMA方式的特点

- DMA与主存交换数据的三种方式
  - 停止CPU访问主存  
    控制简单  
    CPU处于不工作状态或保持状态  
    未充分发挥CPU对主存的利用率
  - 周期挪用（周期窃取）  
    DMA访问主存有三种可能  
    CPU此时不访存 *DMA直接访问*  
    CPU正在访存 *DMA等待*  
    CPU与DMA同时请求访存 *CPU将总线控制权让给DMA*
  - DMA与CPU交替访问

#### DMA的工作过程

- DMA传送过程
  - 预处理
    - 通知DMA控制逻辑传送方向
    - 向DMA设备地址寄存器从入设备号
    - 向DMA主存地址寄存器送入交换数据的主存起始地址
    - 对字计数器赋予交换数据的个数
  - 数据传送  
    ![YuPu7t.png](https://s1.ax1x.com/2020/05/08/YuPu7t.png)
  - 后处理 **由中断服务程序完成**
    - 校验送入主存的数是否正确
    - 是否继续使用DMA
    - 测试传送过程是否正确，错则转诊断程序

#### DMA方式和程序中断方式的比较

||中断方式|DMA方式|
|:-:|:-:|:-:|
|数据传送|程序|硬件|
|响应时间|指令执行结束|存取周期的结束|
|处理异常情况|能|不能|
|中断请求|传输数据|后处理|
|优先级|低|高|

#### DMA接口的类型

- 选择型
  - 在**物理**上连接**多个**设备  
  - 在**逻辑**上只允许连接**一个**设备
- 多路型
  - 在**物理**上连接**多个**设备
  - 在**逻辑**上允许连接**多个**设备同时工作

---

## 第6章 计算机的运算方法

### 6.1 无符号数和有符号数

- 无符号数  
  寄存器的位数反映无符号数的表示范围
- 有符号数  
  - 机器数和真值  
    |真值|机器数|
    |:-|:-|
    |带符号的数|符号数字化的数|
    |+0.1011|0 1011|
    |-0.1011|1 1011|
    |+1100|0 1100|
    |-1100|1 1100|
  - 原码表示法 *带符号的绝对值表示*  
    整数：  
    x=+1110 原=0,1110  
    x=-1110 原=1,1110  
    小数：  
    x=+0.1101 原=0.1101
    x=-0.1101 原=1.1101
  - 补码表示法  
    整数本身；负数取反加1  
    整数：  
    x=+1010 补=0,1010  
    x=-1011000 补=1,0101000
    小数：  
    x=+0.1110 补=0.1110
    x=-0.1100000 补=1.010000
  - 反码表示法  
    正数不变，负数取反
  - 移码表示法  
    使用补码表示不易比较大小  
    $[x]_移=2^n+x (-2^n<x<2^n)$  
    ![YKOHYQ.png](https://s1.ax1x.com/2020/05/08/YKOHYQ.png)  
    移码和补码只有符号位相反，数值位完全相同

### 6.2 数的定点表示和浮点表示

- 定点表示  
  ![YMSFLn.png](https://s1.ax1x.com/2020/05/08/YMSFLn.png)
- 浮点表示
  - 浮点数的一般形式  
    $N=S \times r^j$  
    S尾数 j阶码 r尾数的基值  
    ![YMCgfK.png](https://s1.ax1x.com/2020/05/08/YMCgfK.png)
  - 浮点数的表示范围  
    上溢 阶码>最大阶码 计算出错  
    下溢 阶码<最小阶码 按照机器零处理  
    ![YMPuA1.png](https://s1.ax1x.com/2020/05/08/YMPuA1.png)
  - 浮点数的规格化形式  
    r=2 尾数最高位为1  
    r=4 尾数最高2位不全为0  
    r=8 尾数最高3位不全为0  
  - 浮点数的规格化  
    r=2  
    左规 尾数左移1位，阶码减1  
    右规 尾数右移1位，阶码加1  
    r=4  
    左规 尾数左移2位，阶码减1  
    右规 尾数右移2位，阶码加1  
    r=8  
    左规 尾数左移3位，阶码减1  
    右规 尾数右移3位，阶码加1  
- IEEE754标准  
  阶码采用偏置量127(阶码8位时)的移码表示  
  尾数用源码表示  
  ![YMFjXD.png](https://s1.ax1x.com/2020/05/08/YMFjXD.png)

### 6.3 定点运算

#### 移位运算

- **数据相对于小数点移动**  
  - 左移 绝对值扩大
  - 右移 绝对值缩小
- 算数移位的规则  
  符号位不变  
  ||码制|添补代码|
  |:-:|:-:|:-:|
  |正数|原码、补码、反码|0|
  |负数|原码|0|
  |负数|反码|1|
  |负数|补码|左移0|
  |负数|补码|右移1|
- 算数移位和逻辑移位的区别
  - 算数移位 有符号数的移位（符号位保持不变）
  - 逻辑移位 无符号数的位移
  
#### 加减法运算

- 加法  
  整数 $[A]_补+[B]_补=[A+B]_补 (mod 2^{n+1})$  
  小数 $[A]_补+[B]_补=[A+B]_补 (mod 2)$  
- 减法  
  整数 $[A-B]_补=[A]_补+[-B]_补 (mod 2^{n+1})$  
  小数 $[A-B]_补=[A]_补+[-B]_补 (mod 2)$
- **补码运算符号位参与运算，结果的符号位在运算中产生，符号位产生的进位自动丢掉**

#### 溢出判断

- 一位符号位判溢出
  参加操作的两个数（减法操作时即为被减数和“求补”以后的减数）**符号位相同**，其结果的符号与原操作数的**符号不同**，即为溢出  
  **最高有效位的进位$\bigoplus$符号位的进位=1**  
  若最高有效位进位1，符号位分别为1和0时，由于符号位参与运算，所以此时符号位进位为1。  
- 两位符号位判断溢出  
  - 结果的双符号位**相同** **未溢出**  
  - 结果的双符号位**不同** **溢出**
  - 最高符号位代表真正符号位

#### 乘法运算

- **原码乘法**  
  符号位单独处理  
  部分积初始为0.0000，存在ACC中  
  乘数数值位存放在MQ中  
  根据乘数末位值进行判断：  
  1：部分和+被乘数  
  0：部分和+0  
  每次加法运算后需要右移（逻辑移位）一位，直到乘数全部移出MQ。  
  此时ACC中存放乘积高位，MQ存放乘积低位。最后补充符号位  
  n位小数进行**n次加法，n次移位**  
  硬件：3个寄存器，其中两个具有移位功能
- **补码一位乘法（Booth算法）**  
  乘数被乘数使用补码表示，被乘数和部分积双符号位，乘数单符号位，都参与运算  
  在乘数末位$y_n$后面设置一位附加位$y_{n+1}$，附位初始为0  
  |$y_n$|$y_{n+1}$|操作|
  |:-:|:-:|-|
  |0|0|部分积右移1位|
  |0|1|部分积+$[乘数]_补$，右移1位|
  |1|0|部分积+$[-乘数]_补$，右移1位|
  |1|1|部分积右移1位|
  |||最后一步只+-，不移位|

  n为小数**n次移位**，虽然加上符号位乘数已n+1位，但是最后一步不移位，总体移n次位

- **补码两位乘法**  
  乘数被乘数采用补码表示，被乘数和部分积三符号位，乘数双符号位，在乘数末位$y_n$后面设置一位附加位$y_{n+1}$，附位初始为0  
  |$y_{n-1}$|$y_n$|$y_{n+1}$|操作|
  |:-:|:-:|:-:|-|
  |0|0|0|部分积右移2位|
  |0|0|1|部分积+$[乘数]_补$，右移2位|
  |0|1|0|部分积+$[乘数]_补$，右移2位|
  |0|1|1|部分积+$2[乘数]_补$，右移2位|
  |1|0|0|部分积+$2[乘数]_补$，右移2位|
  |1|0|1|部分积+$[-乘数]_补$，右移2位|
  |1|1|0|部分积+$[-乘数]_补$，右移2位|
  |1|1|1|部分积右移2位|
  ||||最后一步不移位|

  *$y_{n-1}y_n$+$y_{n+1}$的值为1时+1倍乘数，为2时+2倍乘数，为3时-1倍乘数（移动后可时间+3倍乘数）*  
  n位小数进行**n/2次移位**，n为奇数时可以末位填0补成偶数  

#### 除法运算

- **恢复余数除法**
  符号位单独处理，加减除数使用除数绝对值的补码  
  被除数存放在ACC中，商初始值为0.0000存放在MQ中  
  被除数-除数（补码实现）后为正数则够减商1，为负数则不够减商0并且+除数恢复之前的余数  
  每次上商后余数左移（逻辑移位）一位  
  n位小数进行**n+1次上商，n次移位**  
  多一次上商多在整数部分。若第一次上商为0则表示商是一个小于1的数可以继续计算；若第一次上商为1则表示结果大于1了，溢出。  
- **不恢复余数法（加减交替法）**  
  符号位单独处理，加减除数使用除数绝对值的补码  
  第一步依然是-除数，判读是否溢出  
  余数为负上商0：左移+除数  
  余数为正上商1：左移-除数  
  n位小数进行**n+1次上商，n次移位**  
- **补码加减交替除法**  
  被除数和除数采用补码形式表示，符号位参加运算  
  |$[余数]_补$与$[除数]_补$|商|操作|
  |:-:|:-:|-|
  |同号|1|左移+$[-除数]_补$|
  |异号|0|左移+$[除数]_补$|
  |||初始判断被除数与除数符号，上商后不移动直接+-得到第一个余数|
  |||只移位n次，最后一次不再+-除数，商末位恒置1|
  
  n位小时进行**n次移位**

#### 浮点加减运算

- 对阶  
  阶码-1，尾数左移1位  
  阶码+1，尾数右移1位  
  对阶原则：**采用小阶向大阶看齐**  
  原因：小阶增加尾数右移仅仅丢失低位，丢失精度；大阶减小尾数左移丢失高位，数据出现错误  
- 运算
- 规格化（尾数大于0.5，小于1）
  - 尾数为正  
    真值 0.1XXXXX  
    原码 0.**1**XXXXX  
    补码 **0.1**XXXXX  
    反码 0.1XXXXX  
  - 尾数为负  
    真值 -0.1XXXXX  
    原码 1.**1**XXXXX  
    补码 **1.0**XXXXX  
    反码 1.0XXXXX  
  - 源码不论正数负数，第一位小数都为1
  - 补码符号位和第一位小数不同
  - 左规  
    尾数左移1位，阶码-1，直到规格化
  - 右规  
    尾数右移1位，阶码+1  
    当尾数溢出时右归  
- 舍入
  - 0舍1入
  - 末位恒置1法
- 溢出判断

---

## 第7章 指令系统

### 7.1 机器指令

#### 指令的格式

- 操作码字段
  - 长度固定  
    用于指令字长较长的情况，RISC
  - 长度可变  
    操作码分散在指令字的不同字段中
  - 扩展操作码技术  
    操作码的位数随地址数的减少而增加  
    保留码点方法：  
    ![Y8Vxn1.png](https://s1.ax1x.com/2020/05/10/Y8Vxn1.png)
- 地址码字段
  - 四地址  
    |OP|$A_1$|$A_2$|$A_3$|$A_4$|
    |-|-|-|-|-|

    $A_1$ 第一操作数地址  
    $A_2$ 第二操作数地址  
    $A_3$ 结果地址  
    $A_4$ 下一条指令地址  
    4次访存：取指令、取操作数1、取操作数2、保存结果
  - 三地址  
    |OP|$A_1$|$A_2$|$A_3$|
    |-|-|-|-|

  - 二地址  
    |OP|$A_1$|$A_2$|
    |-|-|-|

  - 一地址  
    |OP|$A_1$|
    |-|-|

  - 零地址  
    |op|
    |-|

#### 指令字长

- 指令字长决定于
  - 操作码长度
  - 操作数地址长度
  - 操作数地址个数
- 指令字长固定  
  指令字长小于等于存储字长
- 指令字长可变  
  按字节的倍数变化
- 当用一些硬件资源代替指令字中的地址码字段后
  - 可以扩大指令的寻址范围（减少地址数量）
  - 可缩短指令长度
  - 可减少访存次数（如操作数来自于寄存器）

### 7.2 操作数类型和操作种类

#### 操作数类型

- 地址：无符号整数
- 数字：定点数、浮点数、十进制数
- 字符：ASCII
- 逻辑数：逻辑运算

#### 数据在存储器中的存放方式

- 从任意位置开始存储  
  优点：不浪费存储资源  
  缺点：除了访问一个字节之外，访问其他任何类型的数据都可能需要花费两个存储周期的时间。读写控制比较复杂
- 从一个存储字的起始位置开始访问  
  优点：无论访问何种类型的数据，在一个周期均可完成，读写控制简单。  
  缺点：浪费了存储资源  
- 边界对准方式（从地址的整数倍位置开始访问）  
  数据存放的起始地址是数据长度（通常按照字节计算）的整数倍  
  存取可以在一个周期完成，空间浪费也不太严重

#### 操作类型

- 数据传送  
- 算数逻辑操作
- 移位操作
- 转移
  - 无条件转移
  - 条件转移
  - 调用和返回
  - 陷阱与陷阱指令（意外事故的中断，一般不提供给用户直接使用）
- 输入输出

### 7.3 寻址方式

寻址方式：确定本条指令的操作数地址、下一条要执行指令的指令地址

#### 指令寻址

- 顺序  
  (PC)+1->PC 其中1是指令的字节数
- 跳跃  
  目标地址->PC
  
#### 数据寻址

|操作码|寻址特征|形式地址A|
|-|-|-|

形式地址：指令字中的地址  
有效地址：操作数的真实地址  
约定：指令字长=存储字长=机器字长

##### 1.立即寻址

![Y8tuVS.png](https://s1.ax1x.com/2020/05/10/Y8tuVS.png)

- 指令执行阶段不访存
- A的位数限制了**立即数的范围**

##### 2.直接寻址

![Y8tmb8.png](https://s1.ax1x.com/2020/05/10/Y8tmb8.png)

- 执行阶段访问一次存储器
- A的位数决定了该指令**操作数的寻址范围**
- 操作数的地址不易修改（必须修改A）

##### 3.隐含寻址

![Y8NrFg.png](https://s1.ax1x.com/2020/05/10/Y8NrFg.png)

- 指令字中减少了一个地址字段，可以缩短指令字长

##### 4.间接寻址

![Y8B26J.png](https://s1.ax1x.com/2020/05/10/Y8B26J.png)

- 执行指令阶段2至多次访存
- 可以扩大指令的寻址范围
- 便于编制程序

##### 5.寄存器寻址

![Y8DN4K.png](https://s1.ax1x.com/2020/05/10/Y8DN4K.png)

- 执行阶段不访存，只访问寄存器，执行速度快
- 寄存器个数有限，可缩短指令字长

##### 6.寄存器间接寻址

![Y8D6Et.png](https://s1.ax1x.com/2020/05/10/Y8D6Et.png)

- 有效地址在寄存器中，操作数在存储器中，执行阶段需要访存
- 便于编制循环程序

##### 7.基址寻址

- 采用专用寄存器作基址寄存器  
  ![Y8DLCT.png](https://s1.ax1x.com/2020/05/10/Y8DLCT.png)
  - 可以扩大寻址范围
  - 有利于多道程序
  - BR内容由操作系统或管理程序确定
  - 在程序的执行过程中BR内容不变，形式地址A可变
- 采用通用寄存器作为基址寄存器  
  ![Y8r8xg.png](https://s1.ax1x.com/2020/05/10/Y8r8xg.png)
  - 由用户指定哪个通用寄存器作为基址寄存器
  - 基址寄存器的内容由操作系统确定
  - 在程序的执行过程中$R_0$内容不变，形式地址A可变

##### 8.变址寻址

![Y8r7sH.png](https://s1.ax1x.com/2020/05/10/Y8r7sH.png)

- 可扩大寻址范围
- IX的内容由用户给定
- 在程序的执行过程中IX内容可变，形式地址A不可变
- 便于处理数组问题（将数组首地址存在A中，IX作为数组下标）

##### 9.相对寻址

![Y8yC9K.png](https://s1.ax1x.com/2020/05/10/Y8yC9K.png)

- A的位数决定操作数的寻址范围
- 程序浮动
- 广泛用于转移指令

##### 10.堆栈寻址

- 堆栈
  - 硬堆栈 多个寄存器
  - 软堆栈 指定的存储空间
- 先进后出（一个出口）
- 栈顶地址由SP指出
- 进栈(SP)-1->SP
- 出栈(SP)+1->SP  
![Y86FP0.png](https://s1.ax1x.com/2020/05/10/Y86FP0.png)  
![Y86kGV.png](https://s1.ax1x.com/2020/05/10/Y86kGV.png)

### 7.4 RISC技术

- RISC **精简**指令集计算机
- CISC **复杂**指令集计算机

#### RISC的主要特征

- 选用**使用频率比较高的一些简单指令**，**复杂指令的功能由简单指令来组合**
- 指令长度**固定**、指令格式种类**少**、寻址方式**少**
- 只有**LOAD/STORE**指令访问
- CPU中有**多个通用寄存器**
- 采用流水技术，**一个时钟周期内完成一条指令**
- 采用**组合逻辑**实现控制器

#### CISC的主要特征

- 系统指令复杂庞大，各种指令**使用频率相差大**
- 指令长度**不固定**、指令格式种类**多**、寻址方式**多**
- **访存指令不受限制**
- CPU中设有**专用寄存器**
- 大多数指令需要**多个时钟周期执行完毕**
- 采用**微程序控制器**

#### RISC和CISC的比较

- RISC更能提高计算机运行速度
- RISC便于设计，可降低成本，提高可靠性
- RISC不易实现指令系统兼容

---

## 第8章 CPU的结构和功能

### 8.1 CPU的结构

#### CPU的功能

- 控制器的功能  
  - 取指令
  - 分析指令
  - 执行指令，发出各种操作命令
  - 控制程序输入及结果的输出
  - 总线管理
  - 处理异常情况和特殊请求
- 运算器的功能
  - 实现算术运算和逻辑运算
- CPU需要实现
  - 指令控制
  - 操作控制
  - 时间控制
  - 处理中断
  - 数据加工

#### CPU的寄存器

- 用户可见寄存器
  - 通用寄存器  
    存放操作数，可作为某种寻址方式所需的专用寄存器
  - 数据寄存器  
    存放操作数，两个寄存器拼接存放双倍字长的数据
  - 地址寄存器  
    存放地址，其位数应满足最大的地址范围
  - 条件码寄存器  
    存放条件码，可做程序分支的依据
- 控制寄存器和状态寄存器
  - 控制寄存器  
    PC->MAR->M->MDR->IR  
    控制CPU操作，其中MAR、MDR、IR用户不可见  
    PC用户可见
  - 状态寄存器  
    状态寄存器 *存放条件码*  
    PSW寄存器 *存放程序状态字*

#### 控制单元CU和中断系统

- CU 产生全部指令的微操作命令序列  
  **组合逻辑设计** 硬连线逻辑  
  **微程序设计** 存储逻辑
- 中断系统

### 8.2 指令周期

#### 指令周期的基本概念

- 指令周期  
  取出并执行一条指令所需要的全部时间
  完成一条指令：
  - 取指令、分析指令 （取值周期）
  - 执行 （执行周期）
- 每条指令的指令周期不同
  ![YtHp28.png](https://s1.ax1x.com/2020/05/12/YtHp28.png)
- 具有间接寻址的指令周期
  ![YtH0qH.png](https://s1.ax1x.com/2020/05/12/YtH0qH.png)
- 带有中断周期的指令周期
  ![YtHcJP.png](https://s1.ax1x.com/2020/05/12/YtHcJP.png)
- CPU工作周期的标志  
  CPU访存有四种性质：  
  取指令 （取址周期）  
  取地址（间接寻址）  
  存取操作数或结果 （执行周期）  
  存程序断点 （中断周期）  
  ![YtqejU.png](https://s1.ax1x.com/2020/05/12/YtqejU.png)

#### 指令周期的数据流

- 取值周期数据流  
  ![YtqwEd.png](https://s1.ax1x.com/2020/05/12/YtqwEd.png)  
  取指令结束后要PC+1  
  ![YtqgKS.png](https://s1.ax1x.com/2020/05/12/YtqgKS.png)
- 间址周期数据流  
  ![YtLUzV.png](https://s1.ax1x.com/2020/05/12/YtLUzV.png)
- 执行周期数据流  
  第9章
- 中断周期数据流  
  ![YtOew4.png](https://s1.ax1x.com/2020/05/12/YtOew4.png)

### 8.3 指令流水

#### 如何提高机器速度

- 提高访存速度
  - 高速芯片
  - Cache
  - 多体并行
- 提高IO和主机之间的传送速度
  - 中断
  - DMA
  - 通道
  - 多总线
- 提高运算器速度
  - 高速芯片
  - 改进算法
  - 快速进位链

#### 系统的并行性

- 并行的概念
  - 并发：；两个或两个以上事件在**同一时间段**发生
  - 同时：两个或两个以上事件在**同一时刻**发生
- 并行性的等级
  - 过程级（程序、进程） **粗粒度** 软件实现
  - 指令级（指令之间、指令内部） **细粒度** 硬件实现

#### 指令流水的原理

- 指令的串行执行  
  ![YtvZm8.png](https://s1.ax1x.com/2020/05/12/YtvZm8.png)
- 指令的二级流水  
  ![Ytvlpn.png](https://s1.ax1x.com/2020/05/12/Ytvlpn.png)
- 影响指令流水效率加倍的因素
  - 执行时间>取指时间
    取指令部件-**指令部件缓冲区**-执行指令部件
  - 条件转移指令对指令流水的影响  
    必须等上条指令执行结束，才能确定下一条指令的地址

#### 影响指令流水性能的因素

- 结构相关 不同指令争用同一功能部件产生资源冲突  
  解决办法：
  - 停顿
  - 指令存储器和数据存储器分开
  - 指令预取技术（适用于访存周期短的情况）
- 数据相关  
  不同指令因重叠操作，可能改变操作数的读写访问顺序
  - 写后读相关（RAW）
  - 读后写相关（WAR）
  - 写后写相关（WAW）  
  解决办法：
  - 后推法
  - 采用旁路技术
- 控制相关  
  由转移指令引起

### 8.4 中断系统

#### 引起中断的各种因素

- 人为设置的中断
- 程序性事故（溢出、非法除法）
- 硬件故障
- IO设备
- 外部事件（用键盘中断现行程序）

#### 中断请求标记和中断判优逻辑

- 中断请求标记 INTR
  - 一个请求源 一个**INTR中断请求标记触发器**
  - 多个INTR 组成**中断请求标记寄存器**
    ![YNetHJ.png](https://s1.ax1x.com/2020/05/12/YNetHJ.png)
- 中断判优逻辑
  - 硬件实现（排队器）
    - 分散在各个中断源的接口短路中
    - 集中在CPU内
  - 软件实现（程序查询）  
    ![YNnw6K.png](https://s1.ax1x.com/2020/05/12/YNnw6K.png)

#### 中断服务程序入口地址的寻找

- 硬件向量法  
  ![YUPlkV.png](https://s1.ax1x.com/2020/05/12/YUPlkV.png)
- 软件查询法  
  ![YUPW7t.png](https://s1.ax1x.com/2020/05/12/YUPW7t.png)

#### 中断响应

- 响应中断的条件  
  允许中断触发器 EINT=1
- 响应中断的时间
  指令执行周期结束时刻由CPU发查询信号
- 中断隐指令
  - 保护程序断点  
    断点存于特定地址内或断点进栈
  - 寻找服务程序入口地址  
    向量地址->PC（硬件向量法）  
    中断识别程序入口地址M->PC（软件查询法）
  - 硬件 关中断

#### 保护现场和恢复现场

- 保护现场
  - 断点：中断隐指令完成
  - 寄存器内容：中断服务程序完成
- 恢复现场  中断服务程序完成

#### 多重中断

- 多重中断：当CPU在执行某个中断服务程序的时候，另一个中断源又提出了新的中断请求，而CPU又响应了这个新请求，暂时停止正在运行的服务程序，转去执行新的中断服务程序。
- 实现多重中断的条件
  - 提前设置开中断指令
  - 优先级别高的中断源有权中断优先级别低的中断源  
  ![YUNOtx.png](https://s1.ax1x.com/2020/05/12/YUNOtx.png)
  （中断谁，返回到谁）
- 中断屏蔽技术
  - 屏蔽触发器
  - 屏蔽触发器的值构成屏蔽字（1为屏蔽）
  - 屏蔽技术可以改变处理优先等级
    - 响应优先级 不可改变（由硬件决定）
    - 处理优先级 可改变（重新设置屏蔽字）
  - 设置屏蔽字  
    ![YUa8Zd.png](https://s1.ax1x.com/2020/05/12/YUa8Zd.png)
- 多重中断的断点保护
  - 断点进栈 中断隐指令完成
  - 断点存入“0”地址 中断隐指令完成  
    中断周期 0->MAR  
    命令存储器写  
    PC->MDR 断点->MDR
    （MDR）->存入存储器
- 多重中断如何保护“0”地址  
  ![YUwmjO.png](https://s1.ax1x.com/2020/05/12/YUwmjO.png)

---

## 第9章 控制单元的功能

### 9.1 微操作命令分析

#### 取值周期

- PC->MAR->地址线
- 1->R (CU发出读命令)
- M(MAR)->MDR
- MDR->IR
- OP(IR)->CU
- (PC)+1->PC  
  ![YdYqbj.png](https://s1.ax1x.com/2020/05/13/YdYqbj.png)

#### 间址周期

- Ad(IR)->MAR
- 1->R
- M(MAR)->MDR
- MDR->Ad(IR)(将MDR中的数据传送到IR的地址码部分，此时IR中的指令是操作码+物理地址)  
  ![YdtXOe.png](https://s1.ax1x.com/2020/05/13/YdtXOe.png)

#### 执行周期

- 非访存指令
  - CLA 清空ACC  
    0->ACC  
  - COM 取反
    $\overline{ACC}->ACC$
- 访存指令
  - 加法指令 ADD X
    - Ad(IR)->MAR
    - 1->R
    - M(MAR)->MDR
    - (ACC)+(MDR)->ACC
  - 存数指令 STA X
    - Ad(IR)->MAR
    - 1->W
    - ACC->MDR
    - MDR->M(MAR)
  - 取数指令 LDA X
    - Ad(IR)->MAR
    - 1->R
    - M(MAR)->MDR
    - MDR->ACC
- 转移指令
  - 无条件转移 JMP X
    - Ad(IR)->PC
  - 条件转移 BAN X（负则转）
    - $A_0\cdot Ad(IR)+\overline{A_0}\cdot (PC)->PC$

#### 中断周期

- 保存断点（两种方式）
  - 程序断点存入“0”地址
    - 0->MAR
    - 1->W
    - PC->MDR
    - MDR->M(MAR)
    - 向量地址->PC(或中断识别程序入口地址M->PC)
    - 0->EINT(关中断)
  - 程序断点进栈
    - (SP)-1->MAR
    - 1->W
    - PC->MDR
    - MDR->M(MAR)
    - 向量地址->PC(或中断识别程序入口地址M->PC)
    - 0->EINT(关中断)

### 9.2 控制单元的功能

#### 输入信号

- 时钟  
  CU受时钟控制  
  一个时钟脉冲  
  发一个操作命令或一组需同时执行的操作命令
- 指令寄存器  
  OP(IR)->CU
  控制信号与操作码有关
- 标志  
  CU受标志控制
- 外来信号  
  如中断请求、总线请求

#### 输出信号

- CPU内的各种控制信号  
  $R_i->R_j$  
  (PC)+1->PC  
  ALU +-与或
- 送至控制总线的信号  
  读写命令、中断响应信号

#### 多级时序系统

- 机器周期
  - 机器周期的概念：所有指令执行过程中的一个基准时间
  - 确定机器周期所需要考虑的因素：
    - 每条指令的执行步骤
    - 每一步骤所需的时间
  - 基准时间的确定
    - 以完成最复杂指令功能的时间为准
    - 以访问一次存储器的时间为基准
  - 若指令字长=存储字长，取值周期=机器周期
- 时钟周期  
  一个机器周期内可完成若干个微操作  
  每个微操作需要一定时间  
  将一个机器周期分成若干个时间相等的时间段（节拍、状态、时钟周期）  
  时钟周期是控制计算机操作的最小单位时间  
  用时钟周期控制产生一个或几个微操作命令
- 多级时序系统  
  - 机器周期、节拍组成多级时序系统
  - 一个指令周期包含若干个机器周期
  - 一个机器周期包含若干个时钟周期

#### 控制方式

- 同步控制方式  
  任一微操作均由统一基准时标的时序信号控制
  - 采用定长的机器周期  
    以最长的微操作序列和最复杂的微操作作为标准  
    机器周期内节拍数相同  
  - 采用不定长的机器周期  
    机器周期内节拍数不等
  - 采用中央控制和局部控制相结合的方法  
    将机器的大部分指令安排在统一的、较短的机器周期内完成，成为中央控制  
    将少数操作复杂的指令中的某些操作采用局部控制方式完成  
    ![YwQBKs.png](https://s1.ax1x.com/2020/05/13/YwQBKs.png)
- 异步控制方式
  - 无基准时标信号
  - 无固定的周期节拍和严格的时钟同步
  - 采用应答方式
- 联合控制方式
  同步与异步相结合
- 人工控制方式

---

## 第10章 控制单元的设计

### 10.1 组合逻辑设计

#### 组合逻辑控制单元框图

- CU外特性  
  ![Y0nUrq.png](https://s1.ax1x.com/2020/05/14/Y0nUrq.png)
- 节拍信号  
  ![Y0nwZV.png](https://s1.ax1x.com/2020/05/14/Y0nwZV.png)

#### 微操作的节拍安排

假设：  
采用同步控制方式  
一个机器周期内有3个节拍（时钟周期）  
CPU内部结构采用非总线方式  

- 安排微操作时序的原则
  - 微操作的先后顺序不得随便修改
  - 被控对象不同的微操作尽量安排在一个节拍内完成
  - 占用时间较短的微操作尽量安排在一个节拍内完成并允许有先后顺序
- 取值周期微操作的节拍安排
  ![Y0n0aT.png](https://s1.ax1x.com/2020/05/14/Y0n0aT.png)
- 间址周期微操作的节拍安排
  ![Y0nBIU.png](https://s1.ax1x.com/2020/05/14/Y0nBIU.png)
- 执行周期微操作的节拍安排
  - CLA  
    ![Y0nriF.png](https://s1.ax1x.com/2020/05/14/Y0nriF.png)
  - ADD X  
    ![Y0nsG4.png](https://s1.ax1x.com/2020/05/14/Y0nsG4.png)
  - STA X  
    ![Y0nyRJ.png](https://s1.ax1x.com/2020/05/14/Y0nyRJ.png)
  - LDA X  
    ![Y0n6z9.png](https://s1.ax1x.com/2020/05/14/Y0n6z9.png)
- 中断周期微操作的节拍安排  
  ![Y0ngMR.png](https://s1.ax1x.com/2020/05/14/Y0ngMR.png)

### 10.2 微程序设计

#### 微程序设计思想的产生

![Y0n2s1.png](https://s1.ax1x.com/2020/05/14/Y0n2s1.png)

#### 微程序控制单元框图

- 机器指令对应的微程序
  ![Y0nRqx.png](https://s1.ax1x.com/2020/05/14/Y0nRqx.png)
- 微程序控制单元的基本框图  
  ![Y0nhdK.png](https://s1.ax1x.com/2020/05/14/Y0nhdK.png)
  - 微地址形成部件形成微程序在控制存储器中的首地址  
  - 操作控制字段发出各种控制信号
  - 顺序控制字段指出下一条微指令的地址（下地址）

#### 微程序工作原理

![Y0nfZ6.png](https://s1.ax1x.com/2020/05/14/Y0nfZ6.png)

- 工作原理
  - 取指阶段 执行取值微程序
    ![Y0nIiD.png](https://s1.ax1x.com/2020/05/14/Y0nIiD.png)
  - 执行阶段 执行某个微程序
- 全部微指令存在CM，程序执行过程中只需要读出

#### 微指令的编码方式（控制方式）

- 直接编码（直接控制）方式  
  在为指令的操作控制字段中，每一位代表一个微操作命令  
  ![Y0n4IO.png](https://s1.ax1x.com/2020/05/14/Y0n4IO.png)
- 字段直接编码方式  
  将微指令的控制字段分成若干“段”，每段经过译码后发出控制信号 ![Y0nGGQ.png](https://s1.ax1x.com/2020/05/14/Y0nGGQ.png)
- 字段间接编码方式  
  ![Y0n8Pg.png](https://s1.ax1x.com/2020/05/14/Y0n8Pg.png)
- 混合编码  
  直接编码和字段编码（直接和间接）混合使用

#### 微指令序列地址形成

- 微指令的下地址字段指出
- 根据机器指令的操作码形成
- 增量计数器  
  (CMAR)+1->CMAR
- 分支转移
  |操作控制字段|转移方式|转移地址|
  |-|-|-|

  转移方式：指明判别条件  
  转移地址：指明转移成功后的去向
- 通过测试网络
  ![Y0n1IS.png](https://s1.ax1x.com/2020/05/14/Y0n1IS.png)
- 由硬件产生微程序入口地址  
  第一条指令地址 由专门硬件产生  
  中断周期 由硬件产生中断周期微程序首地址

#### 微指令格式

- 水平型微指令  
  一次能定义并执行多个并行操作
- 垂直型微指令
  类似机器指令操作码的方式  
  由微操作码字段规定微指令的功能
- 两种微指令格式的比较
  - 水平型微指令比垂直型微指令并行操作能力强
  - 水平型微指令执行一条机器指令所需要的微指令数目少，速度快
  - 水平型微指令用较短的微程序结构换取较长的微指令结构，垂直型微指令以较长的微程序结构换取较短的微指令结构
  - 水平型微指令与机器指令差别较大，垂直型微指令与机器指令相似

#### 静态微程序设计和动态微程序设计

- 静态  
  微程序无需改变，采用ROM
- 动态  
  通过改变微指令和微程序改变机器指令，有利于仿真，采用EPROM

#### 毫微程序设计

- 基本概念  
  - 微程序设计用微程序解释机器指令
  - 毫微程序设计用毫微程序解释微指令
  - 毫微指令与微指令的关系好比微指令与机器指令的关系
- 基本组成  
  ![Y0n7zd.png](https://s1.ax1x.com/2020/05/14/Y0n7zd.png)

#### 串行微程序控制和并行微程序控制

![Y0nla8.png](https://s1.ax1x.com/2020/05/14/Y0nla8.png)
